- 환경 변수
    
    환경 변수(environment variables)란 외부 파일에 저장된 키-값 쌍 데이터
    
    환경 변수를 통해 프로그램이 실행될 때의 동작 환경을 외부에서 설정할 수 있도록 한다.
    
    Node.js 애플리케이션이 실행될 때 코드 외부에서 설정할 수 있다.
    
    주로 데이터베이스 접속 정보, API 키, 서버 포트 번호, 경로(Path) 등 민감하거나 환경별로 달라지는 값을 저장하는 데 사용한다.
    
    ```jsx
    DB_HOST=localhost
    DB_USER=myuser
    DB_PASS=mypassword
    ```
    
    Node.js 코드에서 다음과 같이 접근할 수 있다.
    
    ```jsx
    const dbHost = process.env.DB_HOST;
    ```
    
    Node.js에서는 `process.env` 객체를 통해 환경 변수에 접근한다.
    
    코드를 수정하지 않고도 환경별로 설정을 다르게 할 수 있어 보안, 확장성, 유지보수에 좋다!
    
    단, 외부에 .env 파일이 노출되지 않도록 주의해야 한다.
    
- CORS
    
    CORS(Cross-Origin Resource Sharing)는 **웹 브라우저에서 다른 출처**(도메인, 포트, 프로토콜이 다른 경우)**의** **서버 리소스에 접근할 수 있도록 허용**하는 HTTP 표준이다.
    
    ### CORS가 필요한 이유?
    
    - **동일 출처 정책(Same-Origin Policy)**
        
        기본적으로 브라우저는 보안상의 이유로 "동일 출처 정책(Same-Origin Policy)"을 적용시켜, 다른 출처의 API 요청을 차단한다.
        
        동일 출처 정책(Same-Origin Policy): 현재 페이지와 동일한 출처(도메인, 포트, 프로토콜이 같음)에서만 리소스를 자유롭게 요청할 수 있게 제한하는 것
        
    - **현대 웹 구조**
        
        대부분의 웹 기반 서비스는 프론트엔드와 백엔드가 분리되어 있으므로 CORS 설정이 필수적이다!
        
        예) 프론트엔드는 `localhost:3000`, 백엔드는 `localhost:4000`에서 동작한다면, 프론트엔드에서 백엔드로 API 요청 시 CORS 정책에 의해 브라우저가 차단한다.
        
    
    다시 말해, CORS를 이용하면 서버가 특정 출처의 요청을 허용할 수 있다.
    동일 출처 정책을 우회하여, 다른 출처 간 안전하게 리소스를 공유할 수 있도록 하는 HTTP 표준!
    
    브라우저 환경에서 API 서버와 프론트엔드가 다른 출처에 있다면 반드시 CORS 설정이 필요하다.
    
    - 모든 출처 허용
        
        ```jsx
        const cors = require('cors');
        app.use(cors());
        ```
        
        - 이렇게 하면 모든 도메인에서 서버에 요청할 수 있다.
        - 실제 서비스에서는 보안상 위험하므로, 특정 도메인만 허용하는 것이 적절하다.
    - 특정 도메인만 허용
        
        ```jsx
        const corsOptions = {
          origin: 'https://example.com'
        };
        app.use(cors(corsOptions));
        ```
        
        - 여러 도메인을 허용하려면 배열로 설정할 수 있다.
- DB Connection, DB Connection Pool
    
    ### **DB Connection**
    
    애플리케이션(클라이언트)이 데이터베이스와 통신하기 위해 만드는 연결 통로이다.
    
    커넥션을 통해 쿼리를 보내고 결과를 받아올 수 있다.
    
    커넥션을 만들기 위해 서버 주소, DB 이름, 사용자 정보 등으로 구성된 커넥션 스트링이 필요하다.
    
    - 커넥션 기본 흐름:
    connection 열기 → 쿼리 실행 → 결과 받아오기 → connection 닫기
    - 하지만 매번 커넥션을 새로 열고 닫으면 시간이 오래 걸리고, 자원이 낭비된다. 그래서 필요한 것이 커넥션 풀!
    
    ### **DB Connection Pool**
    
    - 커넥션 풀은 여러 개의 DB 커넥션을 만들어 두고, 요청이 들어올 때마다 풀(저장소)에서 필요할 때마다 꺼내 쓰고 반환하는 방식
    - 커넥션 풀이 필요한 이유?
        - **커넥션 생성/종료는 비용이 크다:** 커넥션을 매번 새로 만들고 닫으면 시간이 오래 걸리고, 서버에 부담이 크다.
        - **동시 접속 처리:** 여러 사용자가 동시에 요청할 때, 매번 새 커넥션을 만들면 DB 서버가 과부하될 수 있다.
        - **효율적 자원 관리:** 커넥션 풀을 사용하면 일정 개수의 커넥션만 유지하며, 자원을 효율적으로 관리할 수 있다.
    - 커넥션 풀은 매번 연결을 새로 만들지 않아 속도가 빨라지고, 동시에 많은 요청을 효율적으로 처리할 수 있다.
    
    <aside>
    
    - 커넥션 풀의 동작 방식
        1. 서버가 시작될 때 미리 여러 개의 커넥션을 생성해 풀에 보관
        2. 애플리케이션이 DB 작업을 필요로 하면, 풀에서 커넥션을 하나 빌려 사용한다.
        3. 작업이 끝나면 커넥션을 닫지 않고 풀에 반환
        4. 동시에 많은 요청이 들어오면, 풀에 남은 커넥션이 없을 때까지 빌려 쓸 수 있다.
            
            만약 모두 사용 중이면, 커넥션이 반환될 때까지 대기하거나 에러를 반환한다.
            
    </aside>
    
    - Node.js에서는 `mysql2`, `pg`(PostgreSQL), `mongoose`(MongoDB) 등에서 커넥션 풀을 지원한다.
    
    ```jsx
    const mysql = require('mysql2');
    const pool = mysql.createPool({
      host: 'localhost',
      user: 'user',
      password: 'pass',
      database: 'db',
      connectionLimit: 10 *// 최대 10개 연결 유지*
    });
    ```
    
    여러 사용자가 동시에 DB를 사용해도 효율적으로 자원을 관리할 수 있다.
    
- 비동기 (async, await)
    
    Node.js는 비동기 방식이다.
    
    - **비동기**란, 어떤 작업이 끝날 때까지 기다리지 않고, 다음 코드를 바로 실행하는 방식이다.
    - 예) 파일 읽기, DB 쿼리, 네트워크 요청 등 시간이 오래 걸릴 수 있는 작업을 비동기로 처리하면 서버가 멈추지 않고 여러 작업을 동시에 처리할 수 있다.
    - 이런 비동기 작업을 쉽게 다루기 위한 문법이 **async/await**
    
    <aside>
    
    - `async`
        - `async`로 선언된 함수는 **항상 `Promise`를 반환**한다.
        - 함수 내부에서 반환한 값이 자동으로 `Promise`로 감싸진다.
        - `Promise` 는 자바스크립트의 내장 객체로서, 비동기 작업의 상태와 결과 값을 가지고 있다.
    - `await`
        - `async` 함수 안에서만 사용할 수 있다.
        - 해당 **Promise가 처리될 때까지 기다렸다가**(함수 실행을 일시중지) **결과를 반환**한다.
        - 기다리는 동안에도 다른 작업(이벤트, 요청 등)을 계속 처리할 수 있다.
        - 즉, 비동기 작업이 끝날 때까지 기다렸다가 다음 코드 실행
    </aside>
    
    <aside>
    
    - **async/await가 필요한 이유?**
        - 기존에는 비동기 작업을 콜백(callback)이나 then/catch(Promise 체이닝)으로 처리했다.
        - 하지만, 이러한 방식은 코드가 복잡해질수록 가독성이 떨어지고, 에러 처리가 어려움
        - **async/await**는 비동기 코드를 마치 동기 코드처럼 순차적으로 작성할 수 있게 해주어서, 가독성과 유지보수성이 크게 향상된다.
    </aside>
    
    <aside>
    
    사용법 및 예시:
    
    ```jsx
    async function fetchData() {
      try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
      } catch (error) {
        console.error('Error:', error);
      }
    }
    ```
    
    - `fetchData()` 함수는 Promise를 반환한다. (`async` 함수)
    - `await fetch(...)`는 Promise가 완료될 때까지 기다렸다가 결과(response)를 반환한다.
    - 복잡한 콜백 지옥 없이도 비동기 작업을 순차적으로 처리할 수 있다.
    </aside>
    
- try/catch/finally
    
    `try/catch/finally`는 자바스크립트에서 에러(예외)를 처리하기 위한 구문
    
    - **try**: 예외가 발생할 수 있는 실행 코드 작성
    - **catch**
        - try 블록에서 에러가 발생하면 실행된다.
        - 에러 객체(오류 정보)를 받아서 예외 상황 처리(ex. 에러 메세지 출력, 대체 동작 등)
        - try 블록에서 오류가 발생하지 않으면 catch 블록은 실행되지 않는다.
    - **finally**: 에러 발생 여부와 상관없이 항상 실행되는 코드
    (예: 파일 닫기, 데이터베이스 연결 해제 등)
    
    예시:
    
    ```jsx
    try {
      *// 에러가 발생할 수 있는 코드*
    } catch (error) {
      *// 에러가 발생했을 때 실행되는 코드*
      console.error('에러 발생:', error);
    } finally {
      *// 항상 실행됨 (에러 발생 여부 무관)*
    }
    ```
    
    - catch, finally는 둘 중 하나만 있어도 되지만, try 블록만 단독으로 쓸 수 없다.
    - 이 구조를 사용하면, 예상치 못한 에러로 프로그램이 멈추는 것을 막고, 에러 상황에서도 리소스를 안전하게 정리할 수 있다.